@article{when-dsl,
    author = {Mernik, Marjan and Heering, Jan and Sloane, Anthony M.},
    title = {When and how to develop domain-specific languages},
    year = {2005},
    issue_date = {December 2005},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {37},
    number = {4},
    issn = {0360-0300},
    url = {https://doi.org/10.1145/1118890.1118892},
    doi = {10.1145/1118890.1118892},
    abstract = {Domain-specific languages (DSLs) are languages tailored to a specific application domain. They offer substantial gains in expressiveness and ease of use compared with general-purpose programming languages in their domain of application. DSL development is hard, requiring both domain knowledge and language development expertise. Few people have both. Not surprisingly, the decision to develop a DSL is often postponed indefinitely, if considered at all, and most DSLs never get beyond the application library stage.Although many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to develop a DSL. To aid the DSL developer, we identify patterns in the decision, analysis, design, and implementation phases of DSL development. Our patterns improve and extend earlier work on DSL design patterns. We also discuss domain analysis tools and language development systems that may help to speed up DSL development. Finally, we present a number of open problems.},
    journal = {ACM Comput. Surv.},
    month = {dec},
    pages = {316–344},
    numpages = {29},
    keywords = {Domain-specific language, application language, domain analysis, language development system}
}

@inproceedings{quasiquote-dsl,
    author = {Mainland, Geoffrey},
    title = {Why it's nice to be quoted: quasiquoting for haskell},
    year = {2007},
    isbn = {9781595936745},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1291201.1291211},
    doi = {10.1145/1291201.1291211},
    abstract = {Quasiquoting allows programmers to use domain specific syntax to construct program fragments. By providing concrete syntax for complex data types, programs become easier to read, easier to write, and easier to reason about and maintain. Haskell is an excellent host language for embedded domain specific languages, and quasiquoting ideally complements the language features that make Haskell perform so well in this area. Unfortunately, until now no Haskell compiler has provided support for quasiquoting. We present an implementation in GHC and demonstrate that by leveraging existing compiler capabilities, building a full quasiquoter requires little more work than writing a parser. Furthermore, we provide a compile-time guarantee that all quasiquoted data is type-correct.},
    booktitle = {Proceedings of the ACM SIGPLAN Workshop on Haskell Workshop},
    pages = {73–82},
    numpages = {10},
    keywords = {meta programming, quasiquoting},
    location = {Freiburg, Germany},
    series = {Haskell '07}
}

@misc{mysqli,
    title = {{PHP}: MySQLi},
    publisher = {The PHP Documentation Group},
    url = {https://www.php.net/manual/en/mysqli.quickstart.statements.php}
}

@misc{linq,
    title = {Language Integrated Query (LINQ) - C#},
    author = {Wagner, Bill},
    publisher = {Microsoft},
    year = {2023},
    url = {https://learn.microsoft.com/en-us/dotnet/csharp/linq/}
}

@misc{python-reflection,
    title = {{inspect} - Inspect live objects},
    publisher = {Python Software Foundation},
    url = {https://docs.python.org/3/library/inspect.html}
}

@misc{javascript-reflection,
    title = {Reflect},
    publisher = {{MDN} Web Docs},
    url = {https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect}
}

@misc{java-reflection,
    title = {Core {Java} Reflection},
    publisher = {Oracle},
    url = {https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html}
}

@inproceedings{lisp-reflection,
    title = {Quasiquotation in Lisp},
    author = {Alan Bawden},
    booktitle = {ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
    year = {1999},
    url = {https://api.semanticscholar.org/CorpusID:5254823}
}

@article{idris,
    title = {{Idris}, a general-purpose dependently typed programming language: Design and implementation},
    volume = {23},
    doi = {10.1017/S095679681300018X},
    number = {5},
    journal = {Journal of Functional Programming},
    author = {Brady, Edwin},
    year = {2013},
    pages = {552–593}
}

@article{elab-reflection,
    author = {Christiansen, David and Brady, Edwin},
    title = {Elaborator reflection: extending {Idris} in {Idris}},
    year = {2016},
    issue_date = {September 2016},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {51},
    number = {9},
    issn = {0362-1340},
    url = {https://doi.org/10.1145/3022670.2951932},
    doi = {10.1145/3022670.2951932},
    abstract = {Many programming languages and proof assistants are defined by elaboration from a high-level language with a great deal of implicit information to a highly explicit core language. In many advanced languages, these elaboration facilities contain powerful tools for program construction, but these tools are rarely designed to be repurposed by users. We describe elaborator reflection, a paradigm for metaprogramming in which the elaboration machinery is made directly available to metaprograms, as well as a concrete realization of elaborator reflection in Idris, a functional language with full dependent types. We demonstrate the applicability of Idris’s reflected elaboration framework to a number of realistic problems, we discuss the motivation for the specific features of its design, and we explore the broader meaning of elaborator reflection as it can relate to other languages.},
    journal = {SIGPLAN Not.},
    month = {sep},
    pages = {284–297},
    numpages = {14},
    keywords = {Metaprogramming, dependent types, elaboration}
}

@article{reflection,
    title = {Procedural reflection in programming languages},
    author = {Smith, Brian},
    year = {1982}
}

@article{universal-algebra,
    title = {Universal algebra},
    author = {Birkhoff, Garrett},
    year = {1946},
    journal = {Comptes Rendus du Premier Congrès Canadien de Mathématiques},
    publisher = {University of Toronto Press}
}

@book{general-algebra,
    place = {Cambridge},
    series = {Cambridge Tracts in Mathematics},
    title = {Algebraic Theories: A Categorical Introduction to General Algebra},
    publisher = {Cambridge University Press},
    author = {Adámek, J. and Rosický, J. and Vitale, E. M.},
    year = {2010},
    collection = {Cambridge Tracts in Mathematics}
}

@book{single-sorted,
    title = {A Course in Universal Algebra},
    author = {Burris, S. and Sankappanavar, H.P.},
    isbn = {9783540905783},
    lccn = {81001619},
    series = {Graduate Texts in Mathematics},
    url = {https://www.math.uwaterloo.ca/~snburris/htdocs/ualg.html},
    year = {1981},
    publisher = {Springer New York}
}

@article{hoas,
    author = {Pfenning, F. and Elliott, C.},
    title = {Higher-order abstract syntax},
    year = {1988},
    issue_date = {July 1988},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {23},
    number = {7},
    issn = {0362-1340},
    url = {https://doi.org/10.1145/960116.54010},
    doi = {10.1145/960116.54010},
    abstract = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
    journal = {SIGPLAN Not.},
    month = {jun},
    pages = {199–208},
    numpages = {10}
}

@article{phoas,
    author = {Washburn, Geoffrey and Weirich, Stephanie},
    title = {Boxes go bananas: Encoding higher-order abstract syntax with parametric polymorphism*},
    year = {2008},
    issue_date = {January 2008},
    publisher = {Cambridge University Press},
    address = {USA},
    volume = {18},
    number = {1},
    issn = {0956-7968},
    abstract = {Higher-order abstract syntax is a simple technique for implementing languages with functional programming. Object variables and binders are implemented by variables and binders in the host language. By using this technique, one can avoid implementing common and tricky routines dealing with variables, such as capture-avoiding substitution. However, despite the advantages this technique provides, it is not commonly used because it is difficult to write sound elimination forms (such as folds or catamorphisms) for higher-order abstract syntax. To fold over such a data type, one must either simultaneously define an inverse operation (which may not exist) or show that all functions embedded in the data type are parametric. In this paper, we show how first-class polymorphism can be used to guarantee the parametricity of functions embedded in higher-order abstract syntax. With this restriction, we implement a library of iteration operators over data structures containing functionals. From this implementation, we derive “fusion laws” that functional programmers may use to reason about the iteration operator. Finally, we show how this use of parametric polymorphism corresponds to the Sch\"{u}rmann, Despeyroux and Pfenning method of enforcing parametricity through modal types. We do so by using this library to give a sound and complete encoding of their calculus into System <private-char><inline-graphic mime-subtype="gif" xlink="S0956796807006557_char1"/></private-char>. This encoding can serve as a starting point for reasoning about higher-order structures in polymorphic languages.},
    journal = {J. Funct. Program.},
    month = jan,
    pages = {87–140},
    numpages = {54}
}

@article{compiling-to-categories,
    author = {Elliott, Conal},
    title = {Compiling to categories},
    year = {2017},
    issue_date = {September 2017},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {1},
    number = {ICFP},
    url = {https://doi.org/10.1145/3110271},
    doi = {10.1145/3110271},
    abstract = {It is well-known that the simply typed lambda-calculus is modeled by any cartesian closed category (CCC). This correspondence suggests giving typed functional programs a variety of interpretations, each corresponding to a different category. A convenient way to realize this idea is as a collection of meaning-preserving transformations added to an existing compiler, such as GHC for Haskell. This paper describes such an implementation and demonstrates its use for a variety of interpretations including hardware circuits, automatic differentiation, incremental computation, and interval analysis. Each such interpretation is a category easily defined in Haskell (outside of the compiler). The general technique appears to provide a compelling alternative to deeply embedded domain-specific languages.},
    journal = {Proc. ACM Program. Lang.},
    month = {aug},
    articleno = {27},
    numpages = {27},
    keywords = {domain-specific languages, compile-time optimization, category theory}
}

@article{many-sorted,
    title = {Logic of many-sorted theories},
    volume = {17},
    doi = {10.2307/2266241},
    number = {2},
    journal = {Journal of Symbolic Logic},
    author = {Wang, Hao},
    year = {1952},
    pages = {105–116}
}

@book{graded-algebra,
    title = {Algebra I: Chapters 1-3},
    author = {Bourbaki, N.},
    isbn = {9783540642435},
    lccn = {88031211},
    series = {Actualit{\'e}s scientifiques et industrielles},
    year = {1998},
    publisher = {Springer}
}

@inproceedings{open-module,
    author = {Norell, Ulf},
    title = {Dependently typed programming in {Agda}},
    year = {2009},
    isbn = {9781605584201},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1481861.1481862},
    doi = {10.1145/1481861.1481862},
    abstract = {Dependently typed languages have for a long time been used to describe proofs about programs. Traditionally, dependent types are used mostly for stating and proving the properties of the programs and not in defining the programs themselves. An impressive example is the certified compiler by Leroy (2006) implemented and proved correct in Coq (Bertot and Cast\'{e}ran 2004).Recently there has been an increased interest in dependently typed programming, where the aim is to write programs that use the dependent type system to a much higher degree. In this way a lot of the properties that were previously proved separately can be integrated in the type of the program, in many cases adding little or no complexity to the definition of the program. New languages, such as Epigram (McBride and McKinna 2004), are being designed, and existing languages are being extended with new features to accomodate these ideas, for instance the work on dependently typed programming in Coq by Sozeau (2007).This talk gives an overview of the Agda programming language (Norell 2007), whose main focus is on dependently typed programming. Agda provides a rich set of inductive types with a powerful mechanism for pattern matching, allowing dependently typed programs to be written with minimal fuss. To read about programming in Agda, see the lecture notes from the Advanced Functional Programming summer school (Norell 2008) and the work by Oury and Swierstra (2008).In the talk a number of examples of interesting dependently typed programs chosen from the domain of programming language implementation are presented as they are implemented in Agda.},
    booktitle = {Proceedings of the 4th International Workshop on Types in Language Design and Implementation},
    pages = {1–2},
    numpages = {2},
    keywords = {programming, dependent types},
    location = {Savannah, GA, USA},
    series = {TLDI '09},
    note = {Section 2.7}
}

@phdthesis{het-eq,
    author = "Conor McBride",
    title = "Dependently {T}yped {F}unctional {P}rograms and their {P}roofs",
    school = "University of Edinburgh",
    year = 1999,
    note = {Section 5.1.3, called "John Major" equality}
}
